#!/bin/bash
set -e #Оболочка bash немедленно завершает работу,если любая команда завершается с ненулевым статусом(вызванным состоянием ошибки)
if [ ! -n "$1" ] #Проверяем,передан ли путь
then
	echo "Не указан путь к архиву" >&2
	exit 1
fi

function installation {
command -v $1 >/dev/null
if [ $? -ne 0 ] #если не установлено,то ставим
then
	sudo zypper install -y $1 #потребуется пароль
	echo "$1 : установлено"
fi
}

function assembly_cmake {
	installation cmake
        #Проверяем установлен ли cmake
        cd "/tmp/archives/$1/build-$1"
        rm -rf ./*
        cmake "/tmp/archives/$1/$1"
        make
	return $?
}


function assembly_autotools {
	installation autoconf
        installation automake
        cd "/tmp/archives/$1/$1"
        ./configure
        make
        cp -r ./* "/tmp/archives/$1/build-$1"
}

function install_gems {
	cp -r $2 "/tmp/archives/$1/build-$1"
	sudo gem install $2
}

function assembly_gem {
	gem build $2
	cp -r ./*.gem "/tmp/archives/$1/build-$1"
}


function assembly_php { #У меня 7 версия, поэтому устновка для 7, но дальше надо продумать вопрос версий
	sudo zypper install php7 php7-devel php7-pecl php7-pear
	cd "/tmp/archives/$1/$1"
	/usr/bin/phpize
	./configure
	make
	cp -r ./* "/tmp/archives/$1/build-$1"
}

function assembly_perl_build {
	installation perl
	whereis Module::Build
	if [ $? -ne 0 ]
	then
		sudo cpan Module::Build
	fi
	perl Build.PL
	./Build
	cp -r ./* "/tmp/archives/$1/build-$1"
}

function assembly_perl_make {
	installation perl
	make
	cp -r ./* "/tmp/archives/$1/build-$1"

}

path="$1"
arch=${path##*/} #Выделяем имя архива путем удаления всего текста включительно до последнего разделителя / 
tmp_arch_type=${arch##*.} #Получаем предварительный тип архива
tmp_arch_name=${arch%.*} #Удаляем предварительный тип архива и получаем предварительное имя архива
#Возможно, что архив типа .tar.bz/tar.gz и т.д.
if [[ $tmp_arch_name == *".tar" ]]
then
	arch_type=".tar.$tmp_arch_type"
	arch_name=${tmp_arch_name%.*}
else
	arch_type=".$tmp_arch_type"
	arch_name=$tmp_arch_name
fi
#Получили имя и тип архива
echo $arch_name $arch_type

tdir="/tmp/archives/$arch_name/$arch_name"
trap "rm -rf $tdir" EXIT
#trap выполняет определенное действие при возникновении сигнала
#Тут перехват сгенерированного bash псевдосигнала с именем EXIT. Например, есть сценарий, 
#создающий временный файл. Вместо того, чтобы удалять его в каждом месте выхода из сценария, #просто помещается команда trap в начало сценария, которая удаляет файл при выходе

back_dir=$PWD
#В переменной dir_now будет лежать cd name_dir, где name_dir-имя каталога,в котором находимся сейчас,в котором работаем,в данном случае cd /home/victoria/diplom
if [ ! -d "/tmp/archives" ] #Если нет такого каталога,то создаем
then 
	cd "/tmp" #Ушли из исходной папки
	mkdir "./archives"
	cd $back_dir #Вернулись в исходную папку
fi
new_path="/tmp/archives/$arch_name" #Путь до временного каталога, где будем распаковывать архив
if [ -d "/tmp/archives/$arch_name" ] #Истина,если каталог существует
then 
	echo "Каталог $new_path уже существует"
	#rm -rf "/tmp/archives/$arch_name/*"
	#mkdir "/tmp/archives/$arch_name/build-$arch_name"
else
	cd "/tmp/archives"
	mkdir "./$arch_name"
	cd "./$arch_name"
	mkdir "./build-$arch_name"
	cd $back_dir               
	echo "Каталог $new_path создан"
	echo "Каталог $new_path/build-$arch_name создан"

fi

#Чаще всего в линукс используется архив типа tar.gz
#Тут необходима проверка на факт установки пакета, но в разных системах
#осуществляется по-разному,поэтому пока только для текущей ОС(opensuse)
#и для этой же системы установка

#Если tar не установлен
installation tar
#command -v показывает путь к исполняемому файлу программы (аналог which: which tar)
# $? вернет статус выхода ранее запущенной команды
#0 в случае успеха и 1 в случае ошибки
#/dev/null специальный файл; все,что будет туда записано будет отброшено
#если tar нет,то command -v tar >/dev/null будет иметь код не равный 0
#и значит инверсия этой команды будет равно 0
#если tar есть, то статус выхода command -v tar >/dev/null будет 0
#и при выполнении команды command -v tar в моей системе выводится /usr/bin/tar
#Когда используется опция -v или -V, утилита команды должна предоставить информацию о том, как имя команды интерпретируется оболочкой.

#archiver показывает на тип архиватора

case $arch_type in
*.tar)
	unpack_cmd="tar -xvf"
	archiver=1
	;;
*.tar.bz2 | *.tar.bzip2 | *.tbz2 | *.tb2 | *.tbz)
	unpack_cmd="tar -xvjf"
	archiver=1
	;;
*.tar.xz | *.txz)
	unpack_cmd="tar -xvJf"
	archiver=1
	;;
*.tar.gz | *.tgz)
	unpack_cmd="tar -xvzf"
	archiver=1
	;;
*.gem)
	installation ruby
        #Возникала ошибка для некоторых гемов, удалось решить с помощью пакета ruby-devel
	sudo zypper install ruby-devel
	install_gems $arch_name $path
	archiver=2
	;;	
esac

#Проверка правильности имен в архиве
#Если нашлись подозрительные файлы,то не разархивируем, так как может случится перезапись файлов (Подозрительные пути начинаются с ../ ; /../ ; какая-то-последовательность-символов/../)
#если развернуть архив в какой-то каталог,где уже есть файлы с такими же именами, как в архиве,то будет перезапись
#..-родительская директория текущей папки (на уровень выше текущей папки)
#../dir из текущей папки подняться в родительскую и из родительской перейти в папку с именем dir
#.-текущая папка,текущий каталог, текущая директория
if [ $archiver -eq 1 ]
then
	if [ tar -tf $path | egrep -q '^(.*/)?\.\./' ]
	then
		echo "Подозрительные файлы в архиве"
		exit 1
	else
		#Если нет подозрительных файлов
		cd "/tmp/archives/$arch_name"
		$unpack_cmd $path
		cd $back_dir
		echo "Архив $path разархивирован"
	fi
fi
	
#Поиск файлов-маркеров

#Проверяем установлен ли make
installation make
#-y подставит на вопрос об установке первичной или 
#если пакет уже установлен,но требуется обновление автоматически y(yes)
#The following package is going to be upgraded:.....
#The following NEW package is going to be installed:....
cd "/tmp/archives/$arch_name/$arch_name"
if ! assembly_cmake $arch_name; then 
	echo ":-)"
fi
#Есть файлы и для cmake, и для gnu autotools
if [ -f ./CMakeLists.txt ] && assembly_cmake $arch_name -eq 0 #CMake
then
        assembly_cmake $arch_name
	if [ $? -eq 0 ]
	then
		echo "Собрано с помощью CMake"
        	sudo make -n install
		break
	fi
fi
if [ -f ./configure ] && [ -f ./Makefile.in ] && [ -f ./config.h.in ]#GNU Autotools
then
	assembly_autotools $arch_name
	if [ $? -eq 0 ]
	then		
		echo "Собрано с помощью GNU Autotools"
       		sudo make -n install
		break
	fi
fi
if [ -f ./*.gemspec ]#Ruby
then    
	assembly_gem $arch_name ./*.gemspec
	if [ $? -eq 0 ]
	then
       		echo "Собрано с помощью gem"
		sudo gem install ./*.gem 
		break
	fi
fi
if [ -f ./Rakefile ] && [ ! -f ./*.gemspec ]#Ruby
then    
       	rake --all -n #--dry-run
       	if [ $? -eq 0 ]
       	then    
       		echo "Прогон всех шагов завершен успешно"
       	fi
fi
if [ -f ./config.m4 ]#PHP
then    
	assembly_php $arch_name
	if [ $? -eq 0 ]
	then
       		echo "Собрано с помощью phpize и GNU Autotools"
		sudo make -n install
       		cd ./modules
       		module=$(find *.so)
       		module_name=${module%.*}
       		echo 'extension=$module' | sudo tee /etc/php7/conf.d/$module_name.ini >/dev/null
		break
	fi
fi
if [ -f ./Build.PL ]#Perl
then    
	assembly_perl_build $arch_name
	if [ $? -eq 0 ]
        then
		echo "Собрано с помощью Build и Build.PL"
       		sudo ./Build install
		break
	fi
fi
if [ -f ./Makefile.PL ]#Perl
then
	assembly_perl_make $arch_name
	if [ $? -eq 0 ]
	then
       		echo "Собрано с помощью make и Makefile.PL"
       		sudo make -n install
		break
	fi
fi
        


#GNU Autotools
#исполняемый файл будет в каталоге src
#Пакеты,использующие систему GNU autotools,
#содержат файлы с именами configure,Makefile.in,config.h.in.
#Файлы с суффиксом .in являются шаблонами;идея состоит в том, чтобы запускать сценарий конфигурирования,
#который выявляет характеристики вашей системы, а затем выполняет подстановки в файлах .in для создания реальных файлов сборки. 
#Для конечного пользователя это просто; чтобы создать файл Makefile из файла Makefile.in, запустите команду configure.
#Вы должны получить пространный диагностический вывод, пока сценарий проверяет вашу систему на соответствие необходимым условиям. 
#Если все завершается удачно, команда configure создает один или несколько файлов Makefile и файл config.h, а также файл кэша (config.cache), чтобы ей не приходилось выполнять
#некоторые проверки заново. Теперь можно запустить команду make для компиляции пакета.

# test
						
